# Сети 2
Сегодня подробнее поговорим про разные протоколы и сетевые технологии.

**Дисклеймер:** большая часть сегодняшнего семинара заимствована из лекций Максима Кочукова по сетям. 
Если хотите лучше разобраться в сетях - возьмите этот курс в следующем семестре :)

## Шифрование
**Виды шифрования:**
* *Симметричное* - для шифровки и расшифровки используется один и тот же ключ
* *Асимметричное* - есть *публичный* ключ для шифровки и *приватный* для расшифровки

Разберем протокол RSA, котррый используется для шифрования сетевого трафика, в т.ч. в протоколах SSH и HTTPS.

**RSA**:
1. Берутся два простых числа $p$ и $q$, вычисляется $N=pq$
2. Вычисляется $\phi(N) = (p - 1)(q - 1)$
3. Фиксируется $e < \phi(N)$ такое, что $gcd(e, \phi(N)) = 1$. Вычисляется $d = e^{-1} mod \phi(N)$
4. Приватный ключ: $(e, N)$
5. Публичный ключ: $(d, N)$
6. Шифрование: $C = M^e mod N$
7. Расшифровка: $M = C^d mod N$

**Diffie-Hellman key exchange** - алгоритм для безопасного обмена ключами с помощью публичного канала.
Идейно, есть два участника процесса - A и B, они договориваются об общей (публичной) информации *i*, а потом каждый фиксирует свой локальный (приватный) ключ (*a* и *b* соответственно).
Далее A пересылает B значение некоторой функции $g(i, a)$, а B пересылает A $g(i, b)$. 
Далее каждый вычисляет общий секрет $s = f(a, g(i, b)) = f(b, g(i, a))$ (понятно, что функции f и g должны быть подобраны специальным образом).

### SSL and TLS
На практике для установки безопасных соединений исользуются протоклы SSL и TLS (Security Layer).
Изначально использовался SSL, но в нем было найдено несколько уязвимостей и он был признан устаревшим, поэтому сейчас не используется.

TLS использует систему **сертификатов** - электронных документов, подтверждающих валидность некоторого публичного ключа.
Сертификат содержит информацию о том, кто его выдал, а так же электронную подпись.
Выстраиваются в цепочки, в начале каждой из которых стоят корневые сертификаты, которым доверяет весь интернет.



## HTTP
**HTTP (Hypertext Transfer Protocol** - application layer протокол, используемый в основном для загрузки веб-страниц с помощью гиперссылок.
Первой широко используемой версией HTTP была версия HTTP/1.1. Сейчас чаще используется HTTP/2.

**Достоинства HTTP/2:**
* *Multiplexing* - HTTP/1.1 загружает части страницы одну за другой, и если какая-то часть не доступна, то возникает проблема head-of-line blocking. HTTP/2 решает эту проблему, используя одно TCP-соединение для того, чтобы посылать несколько параллельных спотоков данных.
  Для этого HTTP/2 разбивает данные на сообщения в бинарном формате и нумерует их так, чтобы клиент мог понять, из какого потока пришли данные
* *Prioritization* - HTTP/2 сначала подгружает более значимую часть страницы (текс, ссылки), а потом - менее значимую (например, картинки, стили)
* *Server push* - сервер, использующий HTTP/2, может отослать клиенту данные до того, как клиент их запросит
* *Header compression* - HTTP/1.1 сжимает пересылаемые сообщения для того, чтобы ускорить отправку. HTTP/2 так же сжимает заголовок

## QUIC
На прошлом занятии мы говорили про TCP - протокол транспортного уровня, нужный для поддержания абстракции непрерывного потока данных, передаваемого от одного приложения к другому.

**Недостатки TCP**:
* *Retransmission ambiguity* - невозможность однозначно определить, когда есть необходимость повторной отправки пакета.
* *Head of line blocking* - невозможность отправить новый пакет, если предыдущий не был доставлен
* *Ossification* - многие современные устройства (в частности, роутеры), занимаются парсингом заголовка TCP, поэтому вносить существенные изменения в протокол не представляется возможным
* *Hand shake latency* - как мы помним, для установки TCP-соединения нужно провести хэндшейк: сначала клиент посылает серверу SYN, потом сервер посылает SYN ACK, потом клиент посылает серверу ACK. Это занимает время, равное 1,5 RTT
 
![retransmission ambiguity picture](retransmission_ambiguity.jpg)

Решение - **QUIC**. Это протокол, который работает поверх UDP и оперирует на трех уровнях модели OSI: Application, Security, Transport.

**Достоинства QUIC:**
* **Faster handshake:** на установку соединения с помощью TCP+TLS требовалось 2,5 RTT, для установки QUIC соединения нужно 1 RTT (см. картинки)
* **Multiplexing:** мультиплексирование позволяет использовать несколько параллельных каналов внутри одного QUIC-соединения для отправки сообщений, что решает проблему head-of-line blocking
* **Header encryption:** шифрование полей заголовка (номера пакета, фрейма, ACK, Window, Options) помогает избежать оссификации
![tcp_tls_handshake.jpg](tcp_tls_handshake.jpg)
![quic_hadshake.jpg](quic_hadshake.jpg)


**Недостатки QUIC:**
* Код в userspace - до 2х CPU по сравнению с TCP
* Не дает прироста в производительности в low-latency, low-loss сетях

**Вопрос на подумать:** почему только Google могли внедрить QUIC?

## Как пакет проходит от отправителя к получателю?

### Таблицы маршрутизации
Таблица маршрутизации - набор правил, которыми пользуется маршрутизатор для того, чтобы отправить пакет.

Таблица маршрутизации содержит 3 колонки:
* *Network* - маска подсети (совокупность IP-адресов с общим префиксом)
* *Gateway* - IP-адрес, на который надо перенаправить пакет
* *Interface* - имя интерфейса

*Default gateway* - адрес по умолчанию (как правило, адрес роутера). Если IP-адрес получателя не подошел под маски подсетей из предыдущих строк, то пакет отправляется по адресу default gateway.

Посмотреть таблицу маршрутизации: `netstat -rn` или `ip route` или `route -n`.

### iptables

![quic_hadshake.jpg](iptables.jpg)

 Подробнее про iptables: [статья на Хабре](https://habr.com/ru/articles/747616/)

 iptables - это инструмент для управления сетью в Linux, позволяет управлять пакетами данных, проходящими через ваше устройство.

 Две основные вещи в iptables - *таблицы* и *цепочки*.

 **Таблицы**:
 * *Filter* - для фильтрации пакетов
 * *NAT* - для настройки NAT (Network Address Translation, преобразует локальные IP-адреса во внешние)
 * *Mangle* - для специальной обработки пакетов
 * *Raw* - для обхода системы отслеживания состояний

**Цепочки**:
* *INPUT* - для входящих пакетов, которые направлены нашей системе
* *FORWARD* - для пакетов, проходящих через систему
* *OUTPUT* - для пакетов, исходящих из системы

Настроить работу iptables можно из терминала:
```
# заблокировать входящий трафик от 192.168.0.100
iptables -A INPUT -s 192.168.0.100 -j DROP
# настроить обработку с помощью nfqueue
iptables -A FORWARD -p tcp --dport 80 -j NFQUEUE --queue-num 1
```

# Немножко про Apache и Nginx

Снова [статья на Хабре](https://habr.com/ru/articles/267721/)

### Историческая справка
Apache и Nginx - два самых распространенных веб-сервера с открытым исходным кодом. Apache был разработан первым (в 1995 году), и с 1996 года был самым популярным веб-сервером. 

**10k problem** - требование к ПО работать с 10 тясячими одновременных соединений (такое требование появилось по мере развития интернета).

Изначально Apache поддерживает **fork model**. Она реализована в **mpm_prefork module** - этот модуль создает по одному однопоточному процессу на каждый запрос. Так же есть другие модули - **mpm_worker** (модуль, создающий процессы, каждый из которых может работать с несколькими потоками, прри этом один поток обраюатывает одно соединение) и **mpm_event** (модуль, похожий на mpm_worker, но оптимизированный под работу с keep-alive соединениями).

Nginx поддерживает **multiplexing mode**: создает процессы-воркеры, каждый из которых может обрабатывать тысячи соединений. Каждое обрабатываемое воркером соединение помещается в event loop вместе с отсальными соединениями и обрабатывается асинхронно.

Nginx лучше масштабируется, но с Apache легче работать, т.к. он дольше в работе, и под него написана хорошая документация и он легко интегрируется.



